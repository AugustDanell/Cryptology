# Cryptology
Cryptology is, in a nutshell, the idea of establishing safe communication and its uses go back to antiquiety and maybe even further. The ceasar cipher is one very basic substitution cipher meaning that we substitute each letter according to some table. In the ceasar cipher we add a number for each letter, rolling over to the first letter. The number we choose to use as a form of shifting like this is what is called a key, it is called a key because if our reciveving partner knows the number he, or she, can then subsequently subtract the same number to decipher the message. Naturally this is much safer than leaving the plaintext as it is when in an armed conflict. Today cryptology in a practical sense is obviously much more advanced than the ceasar cipher but it builds on the same principle. In this repo I will implement some of the weaker cryptological stanards as well as more advanced and more practically used today standards like the AES and DES.

## Weak Cryptology
In this Python file I implement those weak cryptological standards, starting with the ceasar cipher and then moving on to ciphers like the Vigenere Cipher, which essentially is using the Ceasar Cipher but with the key being multiple ceasar keys instead (see the file for details). We are then also implementing the Affine Cipher, Auto Key Cipher etc is the plan.

## Playfair Cipher
This cipher is a little bit more complicated than the weak ciphers and it is also a competitive programming problem. The cipher, as can be seen, is composed out of different steps using a key to insert the cipher into a 5x5 Matris, appending the alphabet of all the letters not inside the key, and then applying a set of rules that can be read about in the problem description to the problem: https://open.kattis.com/problems/playfair

## Test Suite 
Like with many projects I like the idea of test driven development, that is, the construction of test to test functions and the assertion that these tests return what the function intends to return. This principle of designing code is, I think, very good in that it allows for the programmer to keep less things in his head knowing that if an unpure function alters something in the code so that previously bugs come anew, the tests will pick up on that.   
